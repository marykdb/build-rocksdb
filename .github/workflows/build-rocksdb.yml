name: Build RocksDB

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: write

jobs:
  linux-x64:
    name: Linux x86_64
    runs-on: ubuntu-latest
    container: ubuntu:18.04
    steps:
      - name: Prepare apt (install git for checkout)
        run: |
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            git curl ca-certificates tzdata build-essential gcc-8 g++-8 \
            pkg-config build-essential cmake ninja-build autoconf automake libtool unzip zip jq
      - name: Manual checkout
        env:
          REPO: ${{ github.repository }}
          REF:  ${{ github.ref }}
        run: |
          git init .
          git config --global --add safe.directory /__w/build-rocksdb/build-rocksdb
          git remote add origin https://github.com/${REPO}.git
          git fetch --depth=1 origin "${REF}"
          git checkout FETCH_HEAD
          git submodule update --init --recursive --depth=1
      - name: Select GCC 8
        run: |
          update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 \
            --slave /usr/bin/g++ g++ /usr/bin/g++-8
          gcc --version
          g++ --version
      - name: Build Linux x86_64 package
        env:
          CC: gcc-8
          CXX: g++-8
        run: ./build.sh linuxX64
      - name: Create or get staging release (linux-x64)
        shell: bash
        id: staging_linux_x64
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="staging-${GITHUB_RUN_ID}"
          OWNER_REPO="${GITHUB_REPOSITORY}"
          API="https://api.github.com/repos/${OWNER_REPO}"
          existing=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/tags/$TAG" || true)
          if echo "$existing" | jq -e '.id' >/dev/null 2>&1; then
            id=$(echo "$existing" | jq -r '.id')
            upload_url=$(echo "$existing" | jq -r '.upload_url' | sed 's/{.*}//')
          else
            created=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" -H "content-type: application/json" \
              -d "{\"tag_name\":\"$TAG\",\"name\":\"Staging $TAG\",\"draft\":true}" \
              "$API/releases")
            id=$(echo "$created" | jq -r '.id')
            upload_url=$(echo "$created" | jq -r '.upload_url' | sed 's/{.*}//')
          fi
          echo "id=$id" >> "$GITHUB_OUTPUT"
          echo "upload_url=$upload_url" >> "$GITHUB_OUTPUT"

      - name: Upload linux-x86_64 ZIP to staging release
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER_REPO: ${{ github.repository }}
          RELEASE_ID: ${{ steps.staging_linux_x64.outputs.id }}
          UPLOAD_URL: ${{ steps.staging_linux_x64.outputs.upload_url }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${OWNER_REPOSITORY:-$GITHUB_REPOSITORY}"
          ASSET="build/archives/rocksdb-linux-x86_64.zip"
          NAME=$(basename "$ASSET")
          assets=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/$RELEASE_ID/assets")
          existing_id=$(echo "$assets" | jq -r ".[] | select(.name==\"$NAME\") | .id" || true)
          if [[ -n "${existing_id:-}" && "${existing_id}" != "null" ]]; then
            curl -sS -X DELETE -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/assets/$existing_id" >/dev/null
          fi
          curl -sS -H "authorization: Bearer $GITHUB_TOKEN" -H "content-type: application/zip" \
            --data-binary @"$ASSET" "$UPLOAD_URL?name=$NAME" >/dev/null

  linux-arm64:
    name: Linux ARM64
    runs-on: ubuntu-24.04-arm
    container: ubuntu:18.04
    steps:
      - name: Prepare apt (install git for checkout)
        run: |
          apt-get update
          DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
            git curl ca-certificates tzdata build-essential gcc-8 g++-8 \
            pkg-config cmake ninja-build autoconf automake libtool unzip zip jq
      - name: Manual checkout
        env:
          REPO: ${{ github.repository }}
          REF:  ${{ github.ref }}
        run: |
          git init .
          git config --global --add safe.directory /__w/build-rocksdb/build-rocksdb
          git remote add origin https://github.com/${REPO}.git
          git fetch --depth=1 origin "${REF}"
          git checkout FETCH_HEAD
          git submodule update --init --recursive --depth=1
      - name: Select GCC 8
        run: |
          update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-8 80 \
            --slave /usr/bin/g++ g++ /usr/bin/g++-8
          gcc --version
          g++ --version
      - name: Build Linux ARM64 package
        env:
          CC: gcc-8
          CXX: g++-8
        run: ./build.sh linuxArm64   # or your KN target name for ARM64
      - name: Create or get staging release (linux-arm64)
        shell: bash
        id: staging_linux_arm64
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="staging-${GITHUB_RUN_ID}"
          OWNER_REPO="${GITHUB_REPOSITORY}"
          API="https://api.github.com/repos/${OWNER_REPO}"
          existing=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/tags/$TAG" || true)
          if echo "$existing" | jq -e '.id' >/dev/null 2>&1; then
            id=$(echo "$existing" | jq -r '.id')
            upload_url=$(echo "$existing" | jq -r '.upload_url' | sed 's/{.*}//')
          else
            created=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" -H "content-type: application/json" \
              -d "{\"tag_name\":\"$TAG\",\"name\":\"Staging $TAG\",\"draft\":true}" \
              "$API/releases")
            id=$(echo "$created" | jq -r '.id')
            upload_url=$(echo "$created" | jq -r '.upload_url' | sed 's/{.*}//')
          fi
          echo "id=$id" >> "$GITHUB_OUTPUT"
          echo "upload_url=$upload_url" >> "$GITHUB_OUTPUT"

      - name: Upload linux-arm64 ZIP to staging release
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OWNER_REPO: ${{ github.repository }}
          RELEASE_ID: ${{ steps.staging_linux_arm64.outputs.id }}
          UPLOAD_URL: ${{ steps.staging_linux_arm64.outputs.upload_url }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${OWNER_REPOSITORY:-$GITHUB_REPOSITORY}"
          ASSET="build/archives/rocksdb-linux-arm64.zip"
          NAME=$(basename "$ASSET")
          assets=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/$RELEASE_ID/assets")
          existing_id=$(echo "$assets" | jq -r ".[] | select(.name==\"$NAME\") | .id" || true)
          if [[ -n "${existing_id:-}" && "${existing_id}" != "null" ]]; then
            curl -sS -X DELETE -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/assets/$existing_id" >/dev/null
          fi
          curl -sS -H "authorization: Bearer $GITHUB_TOKEN" -H "content-type: application/zip" \
            --data-binary @"$ASSET" "$UPLOAD_URL?name=$NAME" >/dev/null

  android-arm32:
    name: Android ARM32
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build pkg-config autoconf automake libtool curl unzip zip
      - name: Build Android ARM32 package
        run: ./build.sh androidNativeArm32
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-android-arm32
          path: build/archives/rocksdb-android-arm32.zip

  android-arm64:
    name: Android ARM64
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build pkg-config autoconf automake libtool curl unzip zip
      - name: Build Android ARM64 package
        run: ./build.sh androidNativeArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-android-arm64
          path: build/archives/rocksdb-android-arm64.zip

  android-x86:
    name: Android x86
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build pkg-config autoconf automake libtool curl unzip zip
      - name: Build Android x86 package
        run: ./build.sh androidNativeX86
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-android-x86
          path: build/archives/rocksdb-android-x86.zip

  android-x64:
    name: Android x86_64
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install build dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential cmake ninja-build pkg-config autoconf automake libtool curl unzip zip
      - name: Build Android x86_64 package
        run: ./build.sh androidNativeX64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-android-x64
          path: build/archives/rocksdb-android-x64.zip

  mingw-x64:
    name: Windows (MinGW) x86_64
    runs-on: windows-2022
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install build dependencies
        run: |
          choco install -y make ninja
      - name: Install LLVM MinGW toolchain
        run: |
          set -euo pipefail
          LLVM_MINGW_VERSION=20250910
          LLVM_MINGW_DIST=llvm-mingw-${LLVM_MINGW_VERSION}-ucrt-x86_64
          ARCHIVE_NAME="${LLVM_MINGW_DIST}.zip"
          ARCHIVE_PATH="$PWD/${ARCHIVE_NAME}"
          curl -sSL -o "$ARCHIVE_PATH" "https://github.com/mstorsjo/llvm-mingw/releases/download/${LLVM_MINGW_VERSION}/${ARCHIVE_NAME}"
          TOOLCHAIN_DIR="$PWD/toolchains"
          mkdir -p "$TOOLCHAIN_DIR"
          rm -rf "$TOOLCHAIN_DIR/${LLVM_MINGW_DIST}"
          python - "$ARCHIVE_PATH" "$TOOLCHAIN_DIR" <<'PY'
          import pathlib, sys, zipfile

          archive = pathlib.Path(sys.argv[1])
          dest = pathlib.Path(sys.argv[2])
          dest.mkdir(parents=True, exist_ok=True)
          with zipfile.ZipFile(archive) as zf:
              zf.extractall(dest)
          PY
          rm -f "$ARCHIVE_PATH"
          LLVM_MINGW_ROOT="$TOOLCHAIN_DIR/${LLVM_MINGW_DIST}"
          if [[ ! -d "$LLVM_MINGW_ROOT" ]]; then
            echo "Expected toolchain directory $LLVM_MINGW_ROOT not found" >&2
            exit 1
          fi
          echo "LLVM_MINGW_ROOT=$LLVM_MINGW_ROOT" >> "$GITHUB_ENV"
          echo "$LLVM_MINGW_ROOT/bin" >> "$GITHUB_PATH"
      - name: Build Windows MinGW package
        run: ./build.sh mingwX64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-mingw-x86_64
          path: build/archives/rocksdb-mingw-x86_64.zip

  mingw-arm64:
    name: Windows (MinGW) ARM64
    runs-on: windows-2022
    defaults:
      run:
        shell: bash
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Install build dependencies
        run: |
          choco install -y make ninja
      - name: Install LLVM MinGW toolchain
        run: |
          set -euo pipefail
          LLVM_MINGW_VERSION=20250910
          LLVM_MINGW_DIST=llvm-mingw-${LLVM_MINGW_VERSION}-ucrt-x86_64
          ARCHIVE_NAME="${LLVM_MINGW_DIST}.zip"
          ARCHIVE_PATH="$PWD/${ARCHIVE_NAME}"
          curl -sSL -o "$ARCHIVE_PATH" "https://github.com/mstorsjo/llvm-mingw/releases/download/${LLVM_MINGW_VERSION}/${ARCHIVE_NAME}"
          TOOLCHAIN_DIR="$PWD/toolchains"
          mkdir -p "$TOOLCHAIN_DIR"
          rm -rf "$TOOLCHAIN_DIR/${LLVM_MINGW_DIST}"
          python - "$ARCHIVE_PATH" "$TOOLCHAIN_DIR" <<'PY'
          import pathlib, sys, zipfile

          archive = pathlib.Path(sys.argv[1])
          dest = pathlib.Path(sys.argv[2])
          dest.mkdir(parents=True, exist_ok=True)
          with zipfile.ZipFile(archive) as zf:
              zf.extractall(dest)
          PY
          rm -f "$ARCHIVE_PATH"
          LLVM_MINGW_ROOT="$TOOLCHAIN_DIR/${LLVM_MINGW_DIST}"
          if [[ ! -d "$LLVM_MINGW_ROOT" ]]; then
            echo "Expected toolchain directory $LLVM_MINGW_ROOT not found" >&2
            exit 1
          fi
          echo "LLVM_MINGW_ROOT=$LLVM_MINGW_ROOT" >> "$GITHUB_ENV"
          echo "$LLVM_MINGW_ROOT/bin" >> "$GITHUB_PATH"
      - name: Build Windows ARM64 MinGW package
        run: ./build.sh mingwArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-mingw-arm64
          path: build/archives/rocksdb-mingw-arm64.zip

  macos-x64:
    name: macOS x86_64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build macOS x86_64 package
        run: ./build.sh macosX64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-macos-x86_64
          path: build/archives/rocksdb-macos-x86_64.zip

  macos-arm64:
    name: macOS ARM64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build macOS ARM64 package
        run: ./build.sh macosArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-macos-arm64
          path: build/archives/rocksdb-macos-arm64.zip

  ios-arm64:
    name: iOS ARM64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build iOS ARM64 package
        run: ./build.sh iosArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-ios-arm64
          path: build/archives/rocksdb-ios-arm64.zip

  ios-simulator-arm64:
    name: iOS Simulator ARM64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build iOS Simulator ARM64 package
        run: ./build.sh iosSimulatorArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-ios-simulator-arm64
          path: build/archives/rocksdb-ios-simulator-arm64.zip

  watchos-arm64:
    name: watchOS arm64_32
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build watchOS arm64_32 package
        run: ./build.sh watchosArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-watchos-arm64
          path: build/archives/rocksdb-watchos-arm64.zip

  watchos-device-arm64:
    name: watchOS Device ARM64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build watchOS Device ARM64 package
        run: ./build.sh watchosDeviceArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-watchos-device-arm64
          path: build/archives/rocksdb-watchos-device-arm64.zip

  watchos-simulator-arm64:
    name: watchOS Simulator ARM64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build watchOS Simulator ARM64 package
        run: ./build.sh watchosSimulatorArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-watchos-simulator-arm64
          path: build/archives/rocksdb-watchos-simulator-arm64.zip

  tvos-arm64:
    name: tvOS ARM64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build tvOS ARM64 package
        run: ./build.sh tvosArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-tvos-arm64
          path: build/archives/rocksdb-tvos-arm64.zip

  tvos-simulator-arm64:
    name: tvOS Simulator ARM64
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - name: Build tvOS Simulator ARM64 package
        run: ./build.sh tvosSimulatorArm64
      - uses: actions/upload-artifact@v4
        with:
          name: rocksdb-tvos-simulator-arm64
          path: build/archives/rocksdb-tvos-simulator-arm64.zip

  publish-release:
    name: Publish Release
    needs:
      - linux-x64
      - linux-arm64
      - mingw-x64
      - mingw-arm64
      - macos-x64
      - macos-arm64
      - ios-arm64
      - ios-simulator-arm64
      - watchos-arm64
      - watchos-device-arm64
      - watchos-simulator-arm64
      - tvos-arm64
      - tvos-simulator-arm64
      - android-arm32
      - android-arm64
      - android-x86
      - android-x64
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          submodules: true
      - uses: actions/download-artifact@v4
        with:
          path: artifacts
      - name: List downloaded artifacts
        run: ls -R artifacts
      - name: Prepare apt (jq for API ops)
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends jq curl ca-certificates
      - name: Determine RocksDB version
        id: rocksdb_version
        run: |
          set -euo pipefail
          version_file="rocksdb/include/rocksdb/version.h"
          if [[ ! -f "$version_file" ]]; then
            echo "RocksDB version header not found at $version_file" >&2
            exit 1
          fi
          version="$(awk '/#define ROCKSDB_MAJOR/{major=$3} /#define ROCKSDB_MINOR/{minor=$3} /#define ROCKSDB_PATCH/{patch=$3} END{if(major==""||minor==""||patch=="") exit 1; printf "%s.%s.%s", major, minor, patch}' "$version_file")"
          if [[ -z "$version" ]]; then
            echo "Failed to parse RocksDB version from $version_file" >&2
            exit 1
          fi
          echo "version=$version" >> "$GITHUB_OUTPUT"
      - name: Set release metadata
        id: release_metadata
        env:
          ROCKSDB_VERSION: ${{ steps.rocksdb_version.outputs.version }}
        run: |
          set -euo pipefail
          if [[ -z "${ROCKSDB_VERSION}" ]]; then
            echo "RocksDB version is empty" >&2
            exit 1
          fi
          timestamp="$(date +'%Y%m%dT%H%M%S')Z"
          echo "timestamp=$timestamp" >> "$GITHUB_OUTPUT"
          echo "tag=rocksdb-${ROCKSDB_VERSION}-${timestamp}" >> "$GITHUB_OUTPUT"
      - name: Get staging release by run ID
        id: get_staging
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="staging-${GITHUB_RUN_ID}"
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}"
          res=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/tags/$TAG")
          id=$(echo "$res" | jq -r '.id')
          upload_url=$(echo "$res" | jq -r '.upload_url' | sed 's/{.*}//')
          if [[ -z "$id" || "$id" == "null" ]]; then
            echo "::error::Staging release with tag $TAG not found. Ensure Linux jobs ran." >&2
            exit 1
          fi
          echo "id=$id" >> "$GITHUB_OUTPUT"
          echo "upload_url=$upload_url" >> "$GITHUB_OUTPUT"

      - name: Upload non-Linux assets to staging release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_ID: ${{ steps.get_staging.outputs.id }}
          UPLOAD_URL: ${{ steps.get_staging.outputs.upload_url }}
        run: |
          set -euo pipefail
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}"

          upload_asset() {
            local path="$1"
            if [[ ! -f "$path" ]]; then
              echo "Skipping missing asset: $path"
              return 0
            fi
            local name
            name=$(basename "$path")
            # Skip linux assets; those were uploaded by the linux jobs
            if [[ "$name" == rocksdb-linux-* ]]; then
              echo "Skipping linux asset already uploaded: $name"
              return 0
            fi
            assets=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/$RELEASE_ID/assets")
            existing_id=$(echo "$assets" | jq -r ".[] | select(.name==\"$name\") | .id" || true)
            if [[ -n "${existing_id:-}" && "${existing_id}" != "null" ]]; then
              curl -sS -X DELETE -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/assets/$existing_id" >/dev/null
            fi
            ctype="application/zip"
            case "$name" in
              *.tar.gz|*.tgz) ctype="application/gzip" ;;
              *.xz) ctype="application/x-xz" ;;
            esac
            echo "Uploading $name ..."
            curl -sS -H "authorization: Bearer $GITHUB_TOKEN" -H "content-type: $ctype" \
                 --data-binary @"$path" "$UPLOAD_URL?name=$name" >/dev/null
          }

          shopt -s globstar nullglob
          for f in artifacts/**/*.zip artifacts/**/*.tar.gz artifacts/**/*.tgz artifacts/**/*.xz; do
            upload_asset "$f"
          done

      - name: Publish release (promote staging)
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ROCKSDB_VERSION: ${{ steps.rocksdb_version.outputs.version }}
          TS: ${{ steps.release_metadata.outputs.timestamp }}
        run: |
          set -euo pipefail
          TAG="staging-${GITHUB_RUN_ID}"
          API="https://api.github.com/repos/${GITHUB_REPOSITORY}"
          res=$(curl -sS -H "authorization: Bearer $GITHUB_TOKEN" "$API/releases/tags/$TAG")
          id=$(echo "$res" | jq -r '.id')
          if [[ -z "$id" || "$id" == "null" ]]; then
            echo "::error::Staging release with tag $TAG not found." >&2
            exit 1
          fi
          NAME="RocksDB ${ROCKSDB_VERSION} builds ${TS}"
          curl -sS -X PATCH -H "authorization: Bearer $GITHUB_TOKEN" -H "content-type: application/json" \
               -d "{\"name\":\"$NAME\",\"draft\":false}" \
               "$API/releases/$id" >/dev/null
